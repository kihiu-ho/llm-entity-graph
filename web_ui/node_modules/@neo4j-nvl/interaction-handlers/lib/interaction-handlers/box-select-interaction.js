import { NODE_EDGE_WIDTH } from '../constants';
import { OverlayRenderer } from '../overlay-renderer/overlay-renderer';
import { BaseInteraction } from './base';
import { getCanvasPosition, getWorldPosition } from './utils';
/**
 * An interaction handler for multi-selecting nodes and relationships.
 * When dragging the cursor, it draws a box on the scene and all nodes and relationships inside the box are selected.
 *
 * For examples, head to the {@link https://neo4j.com/docs/nvl/current/interaction-handlers/#_boxselectinteraction Box Select Interaction documentation page}.
 */
export class BoxSelectInteraction extends BaseInteraction {
    mousePosition;
    startWorldPosition;
    overlayRenderer;
    isBoxSelecting;
    /**
     * Creates a new instance of the multi-select interaction handler.
     * @param nvl - The NVL instance to attach the interaction handler to
     * @param options - Options for the multi-select interaction handler to customize its behavior
     */
    constructor(nvl, options = { selectOnRelease: false }) {
        super(nvl, options);
        this.mousePosition = { x: 0, y: 0 };
        this.startWorldPosition = { x: 0, y: 0 };
        this.overlayRenderer = new OverlayRenderer(this.containerInstance);
        this.isBoxSelecting = false;
        this.addEventListener('mousedown', this.handleMouseDown, true);
        this.addEventListener('mousemove', this.handleDrag, true);
        this.addEventListener('mouseup', this.endBoxSelect, true);
        this.addEventListener('mouseleave', this.endBoxSelect, true);
    }
    handleMouseDown = (event) => {
        if (event.button !== 0) {
            this.isBoxSelecting = false;
            return;
        }
        this.turnOnBoxSelect(event);
    };
    handleDrag = (event) => {
        if (this.isBoxSelecting) {
            const curPos = getCanvasPosition(this.containerInstance, event);
            this.overlayRenderer.drawBox(this.mousePosition.x, this.mousePosition.y, curPos.x, curPos.y);
        }
        else if (event.buttons === 1) {
            this.turnOnBoxSelect(event);
        }
    };
    getHitsInBox = (startPos, endPos) => {
        const inside = (pos, start, end) => {
            const minX = Math.min(start.x, end.x);
            const maxX = Math.max(start.x, end.x);
            const minY = Math.min(start.y, end.y);
            const maxY = Math.max(start.y, end.y);
            return pos.x >= minX && pos.x <= maxX && pos.y >= minY && pos.y <= maxY;
        };
        const positions = this.nvlInstance.getNodePositions();
        const hitNodes = new Set();
        for (const pos of positions) {
            if (inside(pos, startPos, endPos)) {
                hitNodes.add(pos.id);
            }
        }
        const rels = this.nvlInstance.getRelationships();
        const hitRels = [];
        for (const rel of rels) {
            if (hitNodes.has(rel.from) && hitNodes.has(rel.to)) {
                hitRels.push(rel);
            }
        }
        const hitNodeArray = Array.from(hitNodes).map((id) => this.nvlInstance.getNodeById(id));
        return {
            nodes: hitNodeArray,
            rels: hitRels
        };
    };
    endBoxSelect = (event) => {
        if (!this.isBoxSelecting) {
            return;
        }
        this.isBoxSelecting = false;
        this.overlayRenderer.clear();
        const endPosition = getCanvasPosition(this.containerInstance, event);
        const endWorldPosition = getWorldPosition(this.nvlInstance, endPosition);
        const { nodes, rels } = this.getHitsInBox(this.startWorldPosition, endWorldPosition);
        if (this.currentOptions.selectOnRelease === true) {
            this.nvlInstance.updateElementsInGraph(nodes.map((node) => ({ id: node.id, selected: true })), rels.map((rel) => ({ id: rel.id, selected: true })));
        }
        this.callCallbackIfRegistered('onBoxSelect', { nodes, rels }, event);
    };
    /**
     * Removes all related event listeners and the overlay renderer for the box.
     */
    destroy() {
        this.removeEventListener('mousedown', this.handleMouseDown, true);
        this.removeEventListener('mousemove', this.handleDrag, true);
        this.removeEventListener('mouseup', this.endBoxSelect, true);
        this.removeEventListener('mouseleave', this.endBoxSelect, true);
        this.overlayRenderer.destroy();
    }
    turnOnBoxSelect(event) {
        this.mousePosition = getCanvasPosition(this.containerInstance, event);
        this.startWorldPosition = getWorldPosition(this.nvlInstance, this.mousePosition);
        const hits = this.nvlInstance.getHits(event, ['node'], { hitNodeMarginWidth: NODE_EDGE_WIDTH });
        if (hits.nvlTargets.nodes.length > 0) {
            this.isBoxSelecting = false;
        }
        else {
            this.isBoxSelecting = true;
            this.callCallbackIfRegistered('onBoxStarted', event);
            if (this.currentOptions.selectOnRelease === true) {
                this.nvlInstance.deselectAll();
            }
        }
    }
}
