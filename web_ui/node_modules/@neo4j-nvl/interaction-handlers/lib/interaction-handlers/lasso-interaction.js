import concaveman from 'concaveman';
import { NODE_EDGE_WIDTH } from '../constants';
import { OverlayRenderer } from '../overlay-renderer/overlay-renderer';
import { BaseInteraction } from './base';
import { getCanvasPosition, getWorldPosition } from './utils';
const pointDist = 10;
const shapeShowTime = 500;
/**
 * Checks if two lines defined by p1->p2 and p3->p4 are crossing.
 * @internal
 */
export const checkLinesCrossing = (p1, p2, p3, p4) => {
    const denom = (p4[1] - p3[1]) * (p2[0] - p1[0]) - (p4[0] - p3[0]) * (p2[1] - p1[1]);
    if (denom === 0) {
        // This means lines are parallell
        return false;
    }
    const t1 = ((p1[1] - p3[1]) * (p4[0] - p3[0]) - (p1[0] - p3[0]) * (p4[1] - p3[1])) / denom;
    const t2 = ((p3[0] - p1[0]) * (p2[1] - p1[1]) - (p3[1] - p1[1]) * (p2[0] - p1[0])) / denom;
    return t1 > 0 && t1 < 1 && t2 > 0 && t2 < 1;
};
/**
 * Checks if any line segments in the polygon intersect.
 * @internal
 */
export const checkIntersection = (polygon) => {
    for (let i = 0; i < polygon.length - 1; i++) {
        for (let j = i + 2; j < polygon.length; j++) {
            const line1p1 = polygon[i] ?? [0, 0];
            const line1p2 = polygon[i + 1] ?? [0, 0];
            const line2p1 = polygon[j] ?? [0, 0];
            // Handle segment from first to last point
            const jNext = j < polygon.length - 1 ? j + 1 : 0;
            const line2p2 = polygon[jNext] ?? [0, 0];
            if (checkLinesCrossing(line1p1, line1p2, line2p1, line2p2)) {
                return true;
            }
        }
    }
    return false;
};
/**
 * Checks if the point (x, y) is inside the polygon defined by vs.
 * @internal
 */
export const checkPointInside = (x, y, vs) => {
    // ray-casting algorithm based on
    // https://wrf.ecse.rpi.edu/Research/Short_Notes/pnpoly.html
    let isInside = false;
    for (let i = 0, j = vs.length - 1; i < vs.length; j = i, i += 1) {
        const vsI = vs[i];
        const vsJ = vs[j];
        if (vsI === undefined || vsJ === undefined) {
            continue;
        }
        const { x: xi, y: yi } = vsI;
        const { x: xj, y: yj } = vsJ;
        const intersect = yi > y !== yj > y && x < ((xj - xi) * (y - yi)) / (yj - yi) + xi;
        if (intersect) {
            isInside = !isInside;
        }
    }
    return isInside;
};
/**
 * An interaction handler that lets you select nodes and relationships by drawing a lasso around them.
 * When dragging, a line is drawn on the scene and all elements inside are selected.
 *
 * For examples, head to the {@link https://neo4j.com/docs/nvl/current/interaction-handlers/#_lassointeraction Lasso Interaction documentation page}.
 */
export class LassoInteraction extends BaseInteraction {
    active;
    points;
    overlayRenderer;
    /**
     * Creates a new instance of the lasso interaction handler.
     * @param nvl - The NVL instance to attach the interaction handler to
     * @param options - Options for the lasso interaction handler to customize its behavior
     */
    constructor(nvl, options = { selectOnRelease: false }) {
        super(nvl, options);
        this.overlayRenderer = new OverlayRenderer(this.containerInstance);
        this.active = false;
        this.points = [];
        this.addEventListener('mousedown', this.handleMouseDown, true);
        this.addEventListener('mousemove', this.handleDrag, true);
        this.addEventListener('mouseup', this.handleMouseUp, true);
        this.addEventListener('mouseleave', this.endLasso, true);
    }
    startLasso = (event) => {
        const hits = this.nvlInstance.getHits(event, ['node'], { hitNodeMarginWidth: NODE_EDGE_WIDTH });
        if (hits.nvlTargets.nodes.length > 0) {
            this.active = false;
        }
        else {
            this.active = true;
            this.points = [getCanvasPosition(this.containerInstance, event)];
            this.callCallbackIfRegistered('onLassoStarted', event);
            if (this.currentOptions.selectOnRelease === true) {
                this.nvlInstance.deselectAll();
            }
        }
    };
    handleMouseDown = (event) => {
        if (event.button === 0 && !this.active) {
            this.startLasso(event);
        }
    };
    handleDrag = (event) => {
        if (this.active) {
            const lastPoint = this.points[this.points.length - 1];
            if (lastPoint === undefined) {
                return;
            }
            const pos = getCanvasPosition(this.containerInstance, event);
            const dx = Math.abs(lastPoint.x - pos.x);
            const dy = Math.abs(lastPoint.y - pos.y);
            if (dx > pointDist || dy > pointDist) {
                this.points.push(pos);
                this.overlayRenderer.drawLasso(this.points, true, false);
            }
        }
    };
    handleMouseUp = (event) => {
        this.points.push(getCanvasPosition(this.containerInstance, event));
        this.endLasso(event);
    };
    getLassoItems = (points) => {
        const worldPoints = points.map((p) => getWorldPosition(this.nvlInstance, p));
        const nodePositions = this.nvlInstance.getNodePositions();
        const hitNodes = new Set();
        for (const pos of nodePositions) {
            if (pos.x === undefined || pos.y === undefined || pos.id === undefined) {
                continue;
            }
            if (checkPointInside(pos.x, pos.y, worldPoints)) {
                hitNodes.add(pos.id);
            }
        }
        const rels = this.nvlInstance.getRelationships();
        const hitRels = [];
        for (const rel of rels) {
            if (hitNodes.has(rel.from) && hitNodes.has(rel.to)) {
                hitRels.push(rel);
            }
        }
        const hitNodeArray = Array.from(hitNodes).map((id) => this.nvlInstance.getNodeById(id));
        return {
            nodes: hitNodeArray,
            rels: hitRels
        };
    };
    endLasso = (event) => {
        if (!this.active) {
            return;
        }
        this.active = false;
        const pointArrays = this.points.map((p) => [p.x, p.y]);
        const hasCrossings = checkIntersection(pointArrays);
        const hull = (hasCrossings ? concaveman(pointArrays, 2) : pointArrays)
            .map((p) => ({ x: p[0], y: p[1] }))
            .filter((point) => point.x !== undefined && point.y !== undefined);
        this.overlayRenderer.drawLasso(hull, false, true);
        setTimeout(() => this.overlayRenderer.clear(), shapeShowTime);
        const hitItems = this.getLassoItems(hull);
        if (this.currentOptions.selectOnRelease === true) {
            this.nvlInstance.updateElementsInGraph(hitItems.nodes.map((node) => ({ id: node.id, selected: true })), hitItems.rels.map((rel) => ({ id: rel.id, selected: true })));
        }
        this.callCallbackIfRegistered('onLassoSelect', hitItems, event);
    };
    /**
     * Removes all related event listeners and the overlay renderer for the box.
     */
    destroy() {
        this.removeEventListener('mousedown', this.handleMouseDown, true);
        this.removeEventListener('mousemove', this.handleDrag, true);
        this.removeEventListener('mouseup', this.endLasso, true);
        this.removeEventListener('mouseleave', this.endLasso, true);
        this.overlayRenderer.destroy();
    }
}
