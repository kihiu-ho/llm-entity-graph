import { BaseInteraction } from './base';
/**
 * Interaction handler for hovering nodes and relationships.
 *
 * For examples, head to the {@link https://neo4j.com/docs/nvl/current/interaction-handlers/#_hoverinteraction Hover Interaction documentation page}.
 */
export class HoverInteraction extends BaseInteraction {
    currentHoveredElement;
    currentHoveredElementIsNode;
    updates;
    constructor(nvl, options = { drawShadowOnHover: false }) {
        super(nvl, options);
        this.updates = {
            nodes: [],
            relationships: []
        };
        this.addEventListener('mousemove', this.handleHover, true);
    }
    /**
     * Handle mouse hover events
     * @param {MouseEvent} event - The mouse event
     */
    handleHover = (event) => {
        const { nvlTargets } = this.nvlInstance.getHits(event);
        const { nodes = [], relationships = [] } = nvlTargets;
        const mainTarget = nodes[0] ?? relationships[0];
        const hoveredElement = mainTarget?.data;
        if (this.currentElementNeedsUnHover(hoveredElement?.id)) {
            this.unHoverCurrentElement();
        }
        const currentHoveredElementIsNode = hoveredElement !== undefined && nodes[0] !== undefined;
        if (currentHoveredElementIsNode) {
            this.updates.nodes.push({ id: hoveredElement.id, hovered: true });
            this.currentHoveredElement = hoveredElement;
            this.currentHoveredElementIsNode = true;
        }
        else if (mainTarget !== undefined) {
            // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
            const { id, from, to } = hoveredElement;
            this.updates.relationships.push({ id, from, to, hovered: true });
            this.currentHoveredElement = hoveredElement;
            this.currentHoveredElementIsNode = false;
        }
        else {
            this.currentHoveredElement = undefined;
            this.currentHoveredElementIsNode = undefined;
        }
        this.callCallbackIfRegistered('onHover', this.currentHoveredElement, nvlTargets, event);
        // Use pure update API to avoid the previous removed node to be re-added to the scene.
        if (this.currentOptions.drawShadowOnHover === true) {
            const currentNodes = this.nvlInstance.getNodes();
            if (currentNodes.length > 0) {
                this.nvlInstance.updateElementsInGraph(this.updates.nodes, this.updates.relationships);
            }
        }
        this.clearUpdates();
    };
    clearUpdates() {
        this.updates.nodes = [];
        this.updates.relationships = [];
    }
    currentElementNeedsUnHover(newHoveredElementId) {
        return this.currentHoveredElement !== undefined && this.currentHoveredElement.id !== newHoveredElementId;
    }
    unHoverCurrentElement() {
        if (this.currentHoveredElement === undefined) {
            return;
        }
        const update = {
            id: this.currentHoveredElement.id,
            hovered: false
        };
        if (this.currentHoveredElementIsNode === true) {
            this.updates.nodes.push(update);
        }
        else {
            // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
            const { from, to } = this.currentHoveredElement;
            this.updates.relationships.push({ ...update, from, to });
        }
    }
    destroy() {
        this.removeEventListener('mousemove', this.handleHover, true);
    }
}
