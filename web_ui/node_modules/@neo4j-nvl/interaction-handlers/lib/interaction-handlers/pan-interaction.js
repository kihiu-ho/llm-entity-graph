import { difference } from 'lodash';
import { NODE_EDGE_WIDTH } from '../constants';
import { BaseInteraction } from './base';
/**
 * Interaction handler for panning the scene, which is achieved by clicking and moving the scene.
 *
 * For examples, head to the {@link https://neo4j.com/docs/nvl/current/interaction-handlers/#_paninteraction Pan Interaction documentation page}.
 */
export class PanInteraction extends BaseInteraction {
    mousePosition;
    targets;
    shouldPan;
    /**
     * Creates a new instance of the pan interaction handler.
     * @param nvl - The NVL instance to attach the interaction handler to
     */
    constructor(nvl, options = { excludeNodeMargin: false }) {
        super(nvl, options);
        this.mousePosition = { x: 0, y: 0 };
        this.targets = [];
        this.shouldPan = false;
        this.addEventListener('mousedown', this.handleMouseDown, true);
        this.addEventListener('mousemove', this.handleMouseMove, true);
        this.addEventListener('mouseup', this.handleMouseUp, true);
    }
    /**
     * Updates which type of graph elements should hinder panning.
     * @param targets - The graph elements that should hinder panning
     * @param excludeNodeMargin - If true, the node margin will not hinder panning
     * By default, panning is hindered by nodes and relationships.
     *
     * @example
     * ```js
     * import { NVL } from '@neo4j-nvl/base'
     * import { PanInteraction } from '@neo4j-nvl/interaction-handlers'
     *
     * const nvl = new NVL(document.createElement('div'), [{ id: '0' }], [])
     * const panInteraction = new PanInteraction(nvl)
     *
     * // Pan canvas even when dragging on nodes and relationships
     * panInteraction.updateTargets([], true)
     * ```
     */
    updateTargets = (targets, excludeNodeMargin) => {
        this.targets = targets;
        this.currentOptions.excludeNodeMargin = excludeNodeMargin;
    };
    handleMouseDown = (event) => {
        const hits = this.nvlInstance.getHits(event, difference(['node', 'relationship'], this.targets), {
            hitNodeMarginWidth: this.currentOptions.excludeNodeMargin === true ? NODE_EDGE_WIDTH : 0
        });
        if (hits.nvlTargets.nodes.length > 0 || hits.nvlTargets.relationships.length > 0) {
            this.shouldPan = false;
        }
        else {
            this.mousePosition = { x: event.clientX, y: event.clientY };
            this.shouldPan = true;
        }
    };
    handleMouseMove = (evt) => {
        if (!this.shouldPan || evt.buttons !== 1) {
            return;
        }
        const zoom = this.nvlInstance.getScale();
        const { x, y } = this.nvlInstance.getPan();
        const dx = ((evt.clientX - this.mousePosition.x) / zoom) * window.devicePixelRatio;
        const dy = ((evt.clientY - this.mousePosition.y) / zoom) * window.devicePixelRatio;
        this.nvlInstance.setPan(x - dx, y - dy);
        this.callCallbackIfRegistered('onPan', { x: x - dx, y: y - dy }, evt);
        this.mousePosition = { x: evt.clientX, y: evt.clientY };
    };
    handleMouseUp = () => {
        this.shouldPan = false;
    };
    /**
     * Removes the related event listeners from the canvas.
     */
    destroy() {
        this.removeEventListener('mousedown', this.handleMouseDown, true);
        this.removeEventListener('mousemove', this.handleMouseMove, true);
        this.removeEventListener('mouseup', this.handleMouseUp, true);
    }
}
