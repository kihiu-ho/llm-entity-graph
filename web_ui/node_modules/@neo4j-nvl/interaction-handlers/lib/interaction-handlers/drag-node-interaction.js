import { NODE_EDGE_WIDTH } from '../constants';
import { BaseInteraction } from './base';
import { isDraggingMovement } from './utils';
/**
 * Interaction handler for dragging nodes,
 * which is achieved by clicking and moving the node.
 * When multiple nodes are selected, they are all dragged.
 *
 * For examples, head to the {@link https://neo4j.com/docs/nvl/current/interaction-handlers/#_dragnodeinteraction Drag Node Interaction documentation page}.
 */
export class DragNodeInteraction extends BaseInteraction {
    mousePosition;
    mouseDownNode;
    isDragging;
    isDrawing;
    selectedNodes;
    moveSelectedNodes;
    /**
     * Creates a new instance of the drag node interaction handler.
     * @param nvl - The NVL instance to attach the interaction handler to
     */
    constructor(nvl, options = {}) {
        super(nvl, options);
        this.mousePosition = { x: 0, y: 0 };
        this.isDragging = false;
        this.isDrawing = false;
        this.selectedNodes = [];
        this.moveSelectedNodes = false;
        this.addEventListener('mousedown', this.handleMouseDown);
        this.addEventListener('mousemove', this.handleMouseMove);
        this.addEventListener('mouseup', this.handleMouseUp);
    }
    handleMouseDown = (event) => {
        this.mousePosition = { x: event.clientX, y: event.clientY };
        const hits = this.nvlInstance.getHits(event, ['node'], { hitNodeMarginWidth: NODE_EDGE_WIDTH });
        const hitNodes = hits.nvlTargets.nodes.filter((node) => node.insideNode);
        const hitNodeEdges = hits.nvlTargets.nodes.filter((node) => !node.insideNode);
        if (hitNodeEdges.length > 0) {
            this.isDrawing = true;
            this.mouseDownNode = null;
        }
        else if (hitNodes.length > 0) {
            this.mouseDownNode = hits.nvlTargets.nodes[0] ?? null;
        }
        else {
            this.mouseDownNode = null;
        }
        this.selectedNodes = this.nvlInstance.getSelectedNodes();
        if (this.mouseDownNode !== null && this.selectedNodes.map((node) => node.id).includes(this.mouseDownNode.data.id)) {
            this.moveSelectedNodes = true;
        }
        else {
            this.moveSelectedNodes = false;
        }
    };
    handleMouseMove = (evt) => {
        // Avoid conflicts on moving node position in drawing process.
        if (this.mouseDownNode === null || evt.buttons !== 1 || this.isDrawing) {
            return;
        }
        if (!isDraggingMovement(evt, this.mousePosition)) {
            return;
        }
        if (!this.isDragging) {
            if (this.moveSelectedNodes) {
                this.callCallbackIfRegistered('onDragStart', this.selectedNodes, evt);
            }
            else {
                this.callCallbackIfRegistered('onDragStart', [this.mouseDownNode.data], evt);
            }
            this.isDragging = true;
        }
        const zoom = this.nvlInstance.getScale();
        const dx = ((evt.clientX - this.mousePosition.x) / zoom) * window.devicePixelRatio;
        const dy = ((evt.clientY - this.mousePosition.y) / zoom) * window.devicePixelRatio;
        if (this.moveSelectedNodes) {
            this.nvlInstance.setNodePositions(this.selectedNodes.map((node) => ({ id: node.id, x: node.x + dx, y: node.y + dy, pinned: true })), true);
            this.callCallbackIfRegistered('onDrag', this.selectedNodes, evt);
        }
        else {
            this.nvlInstance.setNodePositions([
                {
                    id: this.mouseDownNode.data.id,
                    x: this.mouseDownNode.targetCoordinates.x + dx,
                    y: this.mouseDownNode.targetCoordinates.y + dy,
                    pinned: true
                }
            ], true);
            this.callCallbackIfRegistered('onDrag', [this.mouseDownNode.data], evt);
        }
    };
    handleMouseUp = (evt) => {
        if (this.isDragging) {
            if (this.moveSelectedNodes) {
                this.callCallbackIfRegistered('onDragEnd', this.selectedNodes, evt);
            }
            else {
                this.callCallbackIfRegistered('onDragEnd', [this.mouseDownNode?.data], evt);
            }
        }
        this.isDragging = false;
        this.mouseDownNode = null;
        this.isDrawing = false;
        this.selectedNodes = [];
        this.moveSelectedNodes = false;
    };
    /**
     * Removes all related event listeners from the container.
     */
    destroy = () => {
        this.removeEventListener('mousedown', this.handleMouseDown);
        this.removeEventListener('mousemove', this.handleMouseMove);
        this.removeEventListener('mouseup', this.handleMouseUp);
    };
}
