import NVL from '@neo4j-nvl/base';
import '@testing-library/jest-dom';
import { LassoInteraction, checkIntersection, checkLinesCrossing, checkPointInside } from '../interaction-handlers/lasso-interaction';
jest.mock('@neo4j-nvl/layout-workers');
const testNodes = [
    { id: '0', x: 25, y: 25 },
    { id: '1', x: 200, y: 200 }
];
const testRels = [{ id: '10', from: '0', to: '1' }];
const createMouseEvent = (type, x, y) => {
    return new MouseEvent(type, { button: 0, buttons: 1, clientX: x, clientY: y });
};
describe('LassoInteraction', () => {
    let lassoInteraction;
    let myNVL;
    const startCallback = jest.fn();
    const selectCallback = jest.fn();
    beforeEach(() => {
        myNVL = new NVL(document.createElement('div'), testNodes, testRels, {
            disableWebGL: true,
            initialZoom: 1,
            layout: 'free'
        });
        lassoInteraction = new LassoInteraction(myNVL);
    });
    afterEach(() => {
        lassoInteraction.destroy();
        myNVL.destroy();
        startCallback.mockReset();
        selectCallback.mockReset();
    });
    test('can select individual nodes', () => {
        lassoInteraction.updateCallback('onLassoStarted', startCallback);
        lassoInteraction.updateCallback('onLassoSelect', selectCallback);
        expect(myNVL.getSelectedNodes()).toHaveLength(0);
        const gesture1 = [
            createMouseEvent('mousedown', 0, 0),
            createMouseEvent('mousemove', 50, 0),
            createMouseEvent('mousemove', 20, 50),
            createMouseEvent('mouseup', 0, 0)
        ];
        const gesture2 = [
            createMouseEvent('mousedown', 200, 150),
            createMouseEvent('mousemove', 210, 210),
            createMouseEvent('mouseup', 190, 210)
        ];
        const container = myNVL.getContainer();
        gesture1.forEach((e) => container.dispatchEvent(e));
        gesture2.forEach((e) => container.dispatchEvent(e));
        return new Promise((resolve) => {
            expect(startCallback).toHaveBeenCalledTimes(2);
            expect(selectCallback).toHaveBeenCalledTimes(2);
            expect(selectCallback).toHaveBeenNthCalledWith(1, { nodes: [testNodes[0]], rels: [] }, gesture1[3]);
            expect(selectCallback).toHaveBeenNthCalledWith(2, { nodes: [testNodes[1]], rels: [] }, gesture2[2]);
            resolve();
        });
    });
    test('can select relationships', () => {
        lassoInteraction.updateCallback('onLassoStarted', startCallback);
        lassoInteraction.updateCallback('onLassoSelect', selectCallback);
        expect(myNVL.getSelectedNodes()).toHaveLength(0);
        const gesture = [
            createMouseEvent('mousedown', 0, 0),
            createMouseEvent('mousemove', 250, 0),
            createMouseEvent('mousemove', 240, 240),
            createMouseEvent('mousemove', 100, 200),
            createMouseEvent('mousemove', 0, 50),
            createMouseEvent('mouseup', 0, 0)
        ];
        const container = myNVL.getContainer();
        gesture.forEach((e) => container.dispatchEvent(e));
        return new Promise((resolve) => {
            expect(startCallback).toHaveBeenCalledTimes(1);
            expect(selectCallback).toHaveBeenCalledTimes(1);
            expect(selectCallback).toHaveBeenCalledWith({ nodes: [testNodes[0], testNodes[1]], rels: [testRels[0]] }, gesture[5]);
            resolve();
        });
    });
    test('will not start when node is below pointer when dragging', () => {
        lassoInteraction.updateCallback('onLassoStarted', startCallback);
        lassoInteraction.updateCallback('onLassoSelect', selectCallback);
        expect(myNVL.getSelectedNodes()).toHaveLength(0);
        const gesture1 = [
            createMouseEvent('mousedown', 10, 10),
            createMouseEvent('mousemove', 50, 0),
            createMouseEvent('mousemove', 20, 50),
            createMouseEvent('mouseup', 0, 0)
        ];
        const container = myNVL.getContainer();
        gesture1.forEach((e) => container.dispatchEvent(e));
        return new Promise((resolve) => {
            expect(startCallback).not.toHaveBeenCalled();
            resolve();
        });
    });
    test('test for line crossing utility function', () => {
        const res1 = checkLinesCrossing([0, 0], [10, 10], [10, 0], [0, 10]);
        expect(res1).toBeTruthy();
        const res2 = checkLinesCrossing([10, 10], [227, 182], [390, 10], [100, 100]);
        expect(res2).toBeTruthy();
        const res3 = checkLinesCrossing([5, 5], [5, 20], [10, 10], [20, 10]);
        expect(res3).toBeFalsy();
        const res4 = checkLinesCrossing([10, 10], [20, 10], [15, 10], [25, 10]);
        expect(res4).toBeFalsy();
        const res5 = checkLinesCrossing([880, 416], [872, 404], [868, 392], [856, 378]);
        expect(res5).toBeFalsy();
    });
    test('test for line segment crossing utility function', () => {
        const res1 = checkIntersection([
            [0, 0],
            [10, 0],
            [100, 10],
            [50, 10],
            [50, -10]
        ]);
        expect(res1).toBeTruthy();
        const res2 = checkIntersection([
            [10, 10],
            [227, 182],
            [390, 10],
            [500, 100]
        ]);
        expect(res2).toBeTruthy();
        const res3 = checkIntersection([
            [50, 10],
            [10, 10],
            [10, 50],
            [50, 50]
        ]);
        expect(res3).toBeFalsy();
    });
    test('test for point inside polygon utility function', () => {
        const res1 = checkPointInside(10, 10, [
            { x: 0, y: 0 },
            { x: 10, y: -10 },
            { x: 20, y: 0 },
            { x: 10, y: 20 }
        ]);
        expect(res1).toBeTruthy();
        const res2 = checkPointInside(10, 10, [
            { x: 0, y: 0 },
            { x: 10, y: -10 },
            { x: 20, y: 0 },
            { x: 10, y: 5 }
        ]);
        expect(res2).toBeFalsy();
    });
});
