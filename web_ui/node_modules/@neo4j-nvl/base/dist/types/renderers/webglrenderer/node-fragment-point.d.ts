declare const _default: "uniform mediump float u_zoom;\nuniform mediump float u_glAdjust;\n\nvarying lowp vec4 color;\nvarying lowp float drawDefaultBorder;\nvarying lowp vec3 nodeBorderColor;\nvarying lowp vec3 selectedBorderColor;\nvarying lowp vec3 selectedInnerBorderColor;\nvarying lowp vec3 shadowColor;\nvarying lowp float selected;\nvarying lowp float hovered;\nvarying lowp float varNodeSize;\n\nmediump float circleSize = 0.40;\nmediump float defaultBoderSize = 0.42;\nmediump float innerSelectedRingSize = 0.43;\nmediump float outerSelectedRingSize = 0.47;\nmediump float shadowSize = 0.51;\n\nlowp float getShadowAlpha(lowp float size, lowp float dist) {\n  return (1.0 - smoothstep(size, shadowSize, dist)) * 0.25;\n}\n\nlowp float getCircleAlpha(lowp float ringSize, lowp float nodeSize, lowp float dist) {\n  return color.w - smoothstep(ringSize - nodeSize, ringSize, dist);\n}\n\nvoid main() {\n  lowp float dist = distance(gl_PointCoord, vec2(0.5));\n\n  if (dist > 0.51) {\n    discard;\n  }\n  else {\n    lowp float nodeSize = 1.0 / varNodeSize;\n    lowp float nodeAlpha = getCircleAlpha(circleSize, nodeSize, dist);\n    lowp float borderAlpha = getCircleAlpha(defaultBoderSize, nodeSize, dist);\n    lowp float ringAlpha = getCircleAlpha(innerSelectedRingSize, nodeSize, dist);\n    lowp vec3 finalColor = color.xyz;\n    lowp float finalAlpha = nodeAlpha;\n\n    if (selected > 0.0) {\n      lowp float shadowAlpha = getShadowAlpha(outerSelectedRingSize, dist);\n      lowp float ringAlpha2 = getCircleAlpha(outerSelectedRingSize, nodeSize, dist);\n\n      if (drawDefaultBorder > 0.0) {\n        finalColor = mix(nodeBorderColor, finalColor, nodeAlpha);\n        finalColor = mix(selectedInnerBorderColor, finalColor, borderAlpha);\n        finalColor = mix(selectedBorderColor, finalColor, ringAlpha);\n        finalColor = mix(shadowColor, finalColor, ringAlpha2);\n        finalAlpha = max(shadowAlpha, max(nodeAlpha, max(borderAlpha, ringAlpha2)));\n      } else {\n        finalColor = mix(selectedInnerBorderColor, finalColor, nodeAlpha);\n        finalColor = mix(selectedBorderColor, finalColor, ringAlpha);\n        finalColor = mix(shadowColor, finalColor, ringAlpha2);\n        finalAlpha = max(shadowAlpha, max(nodeAlpha, max(ringAlpha, ringAlpha2)));\n      }\n    } else if (hovered > 0.0) {\n      if (drawDefaultBorder > 0.0) {\n        lowp float shadowAlpha = getShadowAlpha(defaultBoderSize, dist);\n  \n        finalColor = mix(nodeBorderColor, finalColor, nodeAlpha);\n        finalColor = mix(shadowColor, finalColor, borderAlpha);\n        finalAlpha = max(shadowAlpha, max(nodeAlpha, ringAlpha));\n      } else {\n        lowp float shadowAlpha = getShadowAlpha(circleSize, dist);\n\n        finalColor = mix(shadowColor, finalColor, nodeAlpha);\n        finalAlpha = max(shadowAlpha, nodeAlpha);\n      }\n    } else {\n      if (drawDefaultBorder > 0.0) {\n        finalColor = mix(nodeBorderColor, finalColor, nodeAlpha);\n        finalAlpha = borderAlpha;\n      }\n    }\n    gl_FragColor = vec4(finalColor, 1.0) * finalAlpha;\n  }\n}\n";
export default _default;
