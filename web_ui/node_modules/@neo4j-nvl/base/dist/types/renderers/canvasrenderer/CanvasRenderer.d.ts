import type { NvlState } from '../../modules/state/types';
import type { Node } from '../../types/graph-element';
import type { Point } from '../../utils/geometry';
import type { HitTargetNode, HitTargetRelationship } from '../../utils/hittest';
import ArrowBundler from './arrows/ArrowBundler';
export default class CanvasRenderer {
    arrowBundler: ArrowBundler;
    private activeNodes;
    private canvas;
    private context;
    private state;
    private stateDisposers;
    private relationshipThreshold;
    private animationHandler;
    private imageCache;
    private needsRun;
    private nodeVersion;
    private relVersion;
    private waypointVersion;
    private ellipsisWidth;
    /**
     * Creates a new CanvasRenderer.
     * @param canvas {HTMLCanvasElement} - The canvas to render on.
     * @param context {CanvasRenderingContext2D} - The canvas context.
     * @param state {NvlState} - The state.
     * @param options {{ relationshipThreshold: number }} - The visualization options.
     */
    constructor(canvas: HTMLCanvasElement, context: CanvasRenderingContext2D | null, state: NvlState, { relationshipThreshold }?: {
        relationshipThreshold?: number;
    });
    /**
     * Checks if the renderer needs to run.
     * @returns {boolean} - Whether the renderer needs to run
     */
    needsToRun(): boolean;
    /**
     * Processes the updates in nodes and relationships.
     */
    processUpdates(): void;
    /**
     * Draws the nodes and relationships to their positions on the canvas.
     * @param positionArray {Node[]} - The array of nodes to draw
     * @param options {any} - The options for the render
     */
    render(positionArray: Node[], options?: {
        canvas?: HTMLCanvasElement;
        context?: CanvasRenderingContext2D;
        backgroundColor?: string;
        ignoreAnimations?: boolean;
        showCaptions?: boolean;
    }): void;
    private getRelationshipsToRender;
    private getNodesToRender;
    private renderNodes;
    private renderRelationships;
    /**
     * Returns the nodes at the pointer position
     * @param {Point} pointer - the position of the pointer
     * @returns {HitTargetNode[]} - the nodes at the pointer position
     * @todo Sort nodes by distance descending
     */
    getNodesAt(pointer: Point, hitNodeMarginWidth?: number): HitTargetNode[];
    /**
     * Returns the relationships at the pointer position
     * @param {Point} pointer - the position of the pointer
     * @returns {HitTargetRelationship[]} - the relationships at the pointer position
     * @todo: sort relationships by distance descending
     */
    getRelsAt(pointer: Point): HitTargetRelationship[];
    destroy(): void;
    /**
     * Checks if the bounding box is outside of the screen.
     * @param boundingBox - The bounding box to check
     * @param clientWidth - The client width of the canvas
     * @param clientHeight - The client height of the canvas
     * @returns Whether the bounding box is off screen
     * @note This check doesn't catch all items that are off screen but its simple and removes many of them
     */
    private isBoundingBoxOffScreen;
    /**
     * Handles the channel's additions, removals and updates and adds or removes the id from the active nodes.
     * @param channel {Channel<Node>} - The channel to process
     * @param fullData {DataSet<Node>} - The full data
     * @param processUpdates {boolean} - Whether to process channel updates as well
     */
    private handleChannelUpdate;
    /**
     * Handles zoom and pan on the canvas.
     * @param context {CanvasRenderingContext2D} - The canvas context
     * @param canvas {HTMLCanvasElement} - The canvas
     */
    private zoomAndPan;
}
