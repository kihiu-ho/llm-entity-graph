import type { Node, Relationship } from '../types/graph-element';
import '../types/nvl-window-functions';
import type { Point } from '../utils/geometry';
import type { ExternalCallbacks } from './ExternalCallbackHandler';
import type { Layout, LayoutOptions, NvlOptions, NvlState, ZoomOptions } from './state/types';
type SaveToFileOptions = {
    filename?: string;
    backgroundColor?: string;
};
export declare const EVENT_ERROR = "onError";
export declare const EVENT_ZOOM_TRANSITION_DONE = "onZoomTransitionDone";
export declare const EVENT_LAYOUT_DONE = "onLayoutDone";
export declare const EVENT_LAYOUT_STEP = "onLayoutStep";
export declare const EVENT_LAYOUT_COMPUTING = "onLayoutComputing";
export declare const EVENT_WEBGL_CONTEXT_LOST = "onWebGLContextLost";
export default class NvlController {
    private destroyed;
    private readonly state;
    private readonly callbacks;
    private readonly instanceId;
    private readonly glController;
    private readonly webGLContext;
    private readonly webGLMinimapContext;
    private readonly htmlOverlay;
    private hasResized;
    private readonly hierarchicalLayout;
    private readonly gridLayout;
    private readonly freeLayout;
    private readonly d3ForceLayout;
    private readonly forceLayout;
    private readonly canvasRenderer;
    private readonly glCanvas;
    private canvasRect;
    private readonly glMinimapCanvas;
    private readonly c2dCanvas;
    private isInRenderSwitchAnimation;
    private justSwitchedRenderer;
    private justSwitchedLayout;
    private layoutUpdating;
    private layoutComputing;
    private isRenderingDisabled;
    private readonly setRenderSwitchAnimation;
    private readonly stateDisposers;
    private readonly zoomTransitionHandler;
    private currentLayout;
    private readonly layoutTimeLimit;
    private pixelRatio;
    private readonly removeResizeListener;
    private readonly removeMinimapResizeListener;
    private pendingZoomOperation;
    private layoutRunner;
    private animationRequestId;
    private layoutDoneCallback;
    private layoutComputingCallback;
    private currentLayoutType;
    private descriptionElement;
    constructor(state: NvlState, options: NvlOptions);
    private onWebGLContextLost;
    private updateMinimapZoom;
    private startMainLoop;
    updateHtmlOverlay(): void;
    dumpNodes(): Node[];
    dumpRelationships(): Relationship[];
    /**
     * Map a relative Canvas space to the DOM position
     * @param {number} canvasX X position in the canvas space
     * @param {number} canvasY Y position position in the canvas space
     */
    mapCanvasSpaceToRelativePosition(canvasX: number, canvasY: number): {
        x: number;
        y: number;
    };
    /**
     * Map a relative DOM position to the Canvas space
     * @param {*} clientX relative X position from the top left [0..rect.width]
     * @param {*} clientY relative Y position from the top left [0..rect.height]
     */
    mapRelativePositionToCanvasSpace(clientX: number, clientY: number): {
        x: number;
        y: number;
    };
    getNodePositions(): (Node & Point)[];
    setNodePositions(data: Node[], updateLayout?: boolean): void;
    isLayoutMoving(): boolean;
    getNodesOnScreen(): {
        nodes: Node[];
        rels: Relationship[];
    };
    registerDoneCallback(cb: NvlController['layoutDoneCallback']): void;
    registerComputingCallback(cb: NvlController['layoutComputingCallback']): void;
    getPosition(nodeId: string): Node;
    getScale(): number;
    getPan(): {
        x: number;
        y: number;
    };
    setZoomLevel(_newLevel: number): void;
    setPanCoordinates(panX: number, panY: number): void;
    setZoomAndPan(zoom: number, panX: number, panY: number): void;
    fit(nodeIds: string[], zoomOptions?: ZoomOptions): void;
    resetZoom(): void;
    setRenderer(renderer: string): void;
    on(name: keyof ExternalCallbacks, callback: (args: unknown) => void): void;
    isDestroyed(): boolean;
    destroy(): void;
    callIfRegistered(...args: any[]): void;
    getCanvasRelsAt(point: Point): import("../utils/hittest").HitTargetRelationship[];
    getCanvasNodesAt(point: Point, hitNodeMarginWidth?: number): import("../utils/hittest").HitTargetNode[];
    private getLayout;
    setLayout(layoutType: Layout): void;
    setLayoutOptions(options: LayoutOptions): void;
    createDownloadLink(filename: string, canvas: HTMLCanvasElement): HTMLAnchorElement;
    saveToFile(options: SaveToFileOptions): void;
    prepareLargeFileForDownload(options: SaveToFileOptions): Promise<unknown>;
    saveFullGraphToLargeFile(options: SaveToFileOptions): Promise<void>;
}
export {};
