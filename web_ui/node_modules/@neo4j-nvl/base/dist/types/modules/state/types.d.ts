import type { LogLevelDesc } from 'loglevel';
import type { WaypointPath } from '../../renderers/canvasrenderer/types';
import type { ExternalCallbacks } from '../ExternalCallbackHandler';
import type { NodeDataSet, RelationshipDataSet } from '../dataset';
type RingStyle = {
    width?: number;
    widthFactor?: number;
    color: string;
};
export type ShadowStyle = {
    width: number;
    opacity: number;
    color: string;
};
export type BorderStyle = {
    rings?: RingStyle[];
    shadow?: ShadowStyle;
};
/**
 * @internal
 */
export type BorderStyles = {
    selected: BorderStyle;
    default: BorderStyle;
};
/**
 * @internal
 */
export type DisabledItemStyles = {
    color: string;
    fontColor: string;
};
/**
 * The options for the force directed layout
 */
export interface ForceDirectedOptions {
    /**
     * @internal
     */
    gravity?: number;
    /**
     * @internal
     */
    intelWorkaround?: boolean;
    /**
     * @internal
     */
    enableCytoscape?: boolean;
    /**
     * @internal
     */
    enableVerlet?: boolean;
    /**
     * @internal
     */
    simulationStopVelocity?: number;
}
/**
 * The options for the hierarchical layout
 */
export interface HierarchicalOptions {
    /** The direction in which the layout should be oriented */
    direction?: 'up' | 'down' | 'left' | 'right';
    /** The packing method to be used */
    packing?: 'bin' | 'stack';
}
export declare const isHierarchicalLayoutOptions: (options: LayoutOptions) => options is HierarchicalOptions;
/**
 * The name of the force directed layout
 */
export declare const ForceDirectedLayoutType = "forceDirected";
/**
 * The name of the hierarchical layout
 */
export declare const HierarchicalLayoutType = "hierarchical";
/**
 * The name of the grid layout
 * @internal
 */
export declare const GridLayoutType = "grid";
/**
 * The name of the free layout
 * @internal
 */
export declare const FreeLayoutType = "free";
/**
 * The name of the d3 force layout
 * @internal
 */
export declare const d3ForceLayoutType = "d3Force";
export declare const WebGLRendererType = "webgl";
export declare const CanvasRendererType = "canvas";
/**
 * The different types of layouts available
 */
export type Layout = typeof ForceDirectedLayoutType | typeof HierarchicalLayoutType | typeof GridLayoutType | typeof FreeLayoutType | typeof d3ForceLayoutType;
export type LayoutOptions = ForceDirectedOptions | HierarchicalOptions;
/**
 * The different types of renderers available
 */
export type Renderer = typeof WebGLRendererType | typeof CanvasRendererType;
/** Configurations for a NVL instance */
export interface NvlOptions {
    /**
     * @internal
     * Id for uniquely identifying the instance of Nvl
     */
    instanceId?: string;
    /** The graph layout algorithm to be used */
    layout?: Layout;
    /**
     * The minimum zoom level allowed
     * @default 0.075
     */
    minZoom?: number;
    /**
     * The maximum zoom level allowed
     * @default 10
     */
    maxZoom?: number;
    /**
     * Whether or not to dynamically allow decreasing minimum zoom value
     * if current graph does not fit on screen at minimum zoom.
     * When set to true, zoom and fit operations will allow zooming out
     * further than the minimum zoom value if the graph does not fit on screen.
     * When set to false, zoom and fit operations will stop at the minimum zoom value,
     * even if the full graph does not fit on screen at that zoom level.
     * @defaultValue true
     */
    allowDynamicMinZoom?: boolean;
    /**
     * @internal
     * @deprecated
     * The DOM element in which to render the graph visualization
     */
    frame?: HTMLElement;
    /**
     * The DOM container in which to render the minimap.
     *
     * @note When using a React ref, make sure the attached element is rendered before the NVL instance is created.
     * Otherwise, the minimap will not be displayed.
     */
    minimapContainer?: HTMLElement;
    /** Configuration for the current layout */
    layoutOptions?: LayoutOptions;
    /** X-coordinate for panning of the current viewport */
    panX?: number;
    /** Y-coordinate for panning of the current viewport */
    panY?: number;
    /** Zoom value of the current viewport */
    initialZoom?: number;
    /**
     * @deprecated use {@link renderer} instead
     * Whether to user the Canvas or WebGL renderer
     * Will be ignored when {@link renderer} is set
     */
    useWebGL?: boolean;
    /**
     * What renderer to use
     * Possible values are 'webgl' or 'canvas'
     * @defaultValue 'webgl'
     * WebGL renderer uses GPU and has better performance.
     * Captions and arrowheads are only displayed when using the canvas renderer.
     */
    renderer?: Renderer;
    /**
     * @internal
     * Whether or not to disable WebGL completely.
     */
    disableWebGL?: boolean;
    /**
     * @internal
     * Specify the log level.
     */
    logging?: {
        level: LogLevelDesc;
    };
    /**
     * @internal
     */
    relationshipThreshold?: number;
    callbacks?: ExternalCallbacks;
    styling?: {
        defaultNodeColor?: string;
        defaultRelationshipColor?: string;
        /** The color to use for the default border of nodes */
        nodeDefaultBorderColor?: string;
        /** The color to use for the selected border of nodes and relationships */
        selectedBorderColor?: string;
        /** The color to use for the selected inner border of nodes and relationships */
        selectedInnerBorderColor?: string;
        /** The color to use for the drop shadow of selected/hovered nodes and relationships */
        dropShadowColor?: string;
        /** The color to use for the disabled nodes and relationships */
        disabledItemColor?: string;
        /** The color to use for the labels of the disabled nodes and relationships */
        disabledItemFontColor?: string;
        /** The color to use for the viewport box in the minimap */
        minimapViewportBoxColor?: string;
    };
    /**
     * The color to use for the default border of nodes
     * @deprecated Use {@link styling.nodeDefaultBorderColor} instead
     */
    nodeDefaultBorderColor?: string;
    /**
     * The color to use for the selected border of nodes
     * @deprecated Use {@link styling.selectedBorderColor} instead
     */
    selectedBorderColor?: string;
    /**
     * The color to use for the disabled nodes and relationships
     * @deprecated Use {@link styling.disabledItemColor} instead
     */
    disabledItemColor?: string;
    /**
     * The color to use for the labels of the disabled nodes and relationships
     * @deprecated Use {@link styling.disabledItemFontColor} instead
     */
    disabledItemFontColor?: string;
    /**
     * @internal
     * Defines a time limit for how long layout iterations may run
     */
    layoutTimeLimit?: number;
    /**
     * Disables tracking of library usage
     * @defaultValue false
     */
    disableTelemetry?: boolean;
    /**
     * Disables the use of {@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers | web workers} for the layout calculations.
     */
    disableWebWorkers?: boolean;
    /**
     * Disables {@link https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA | ARIA} attributes on the graph.
     * By default, NVL adds ARIA attributes to the graph container to make it more accessible.
     * Attributes include `role="image"`, `aria-label="Graph visualization"`
     * and `aria-describedby="nvl-${instanceId}-description"`.
     * The description element is a live region that will announce changes to the graph.
     * @defaultValue false
     */
    disableAria?: boolean;
}
/** Options that influence how fit-to-zoom should behave */
export type ZoomOptions = {
    /** If true, will zoom out to fit the specified nodes without changing the pan of the viewport. */
    noPan?: boolean;
    /** If true, will only zoom out if specified nodes won't fit into viewport but won't zoom in any further. */
    outOnly?: boolean;
    /** The minimum zoom value for the fit-to-zoom operation. */
    minZoom?: number;
    /** The maximum zoom value for the fit-to-zoom operation. */
    maxZoom?: number;
    /** If true, will not animate the zoom/pan transition. */
    animated?: boolean;
};
export interface NvlState {
    zoom: number;
    zoomOptions: ZoomOptions;
    minimapZoom: number;
    defaultZoomLevel: number;
    panX: number;
    panY: number;
    minimapPanX: number;
    minimapPanY: number;
    fitNodeIds: string[];
    resetZoom: boolean;
    forceWebGL: boolean;
    webGLVisible: boolean;
    renderer: Renderer;
    disableWebGL: boolean;
    disableWebWorkers: boolean;
    disableTelemetry: boolean;
    fitMovement: number;
    layout: Layout;
    layoutOptions: LayoutOptions;
    maxNodeRadius: number;
    maxDistance: number;
    minZoom: number;
    maxZoom: number;
    minMinimapZoom: number;
    maxMinimapZoom: number;
    nodes: NodeDataSet;
    rels: RelationshipDataSet;
    graphUpdates: number;
    waypoints: {
        data: Record<string, WaypointPath>;
        counter: number;
    };
    setGraphUpdated: Function;
    setRenderer: Function;
    setWaypoints: Function;
    setZoomPan: Function;
    setZoom: (zoom: number, rect: HTMLElement) => void;
    setPan: Function;
    setLayout: Function;
    setLayoutOptions: Function;
    fitNodes: Function;
    setZoomReset: Function;
    clearFit: Function;
    clearReset: Function;
    updateZoomToFit: Function;
    updateMinimapZoomToFit: Function;
    autorun: Function;
    reaction: Function;
    nodeBorderStyles: BorderStyles;
    relationshipBorderStyles: BorderStyles;
    disabledItemStyles: DisabledItemStyles;
    defaultNodeColor: string;
    defaultRelationshipColor: string;
    minimapViewportBoxColor: string;
}
export {};
