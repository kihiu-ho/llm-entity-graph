declare const _default: "precision lowp float;\n\nuniform sampler2D u_physData;\nuniform float u_index;\n\nfloat shift_right (float v, float amt) { \n    v = floor(v) + 0.5; \n    return floor(v / exp2(amt)); \n}\n\nfloat shift_left (float v, float amt) { \n    return floor(v * exp2(amt) + 0.5); \n}\n\nfloat mask_last (float v, float bits) { \n    return mod(v, shift_left(1.0, bits)); \n}\n\nfloat extract_bits (float num, float from, float to) { \n    from = floor(from + 0.5); to = floor(to + 0.5); \n    return mask_last(shift_right(num, from), to - from); \n}\n\n// From https://stackoverflow.com/questions/17981163/webgl-read-pixels-from-floating-point-render-target\nvec4 encode_float (float val) { \n    if (val == 0.0) return vec4(0, 0, 0, 0); \n    float sign = val > 0.0 ? 0.0 : 1.0; \n    val = abs(val); \n    float exponent = floor(log2(val)); \n    float biased_exponent = exponent + 127.0; \n    float fraction = ((val / exp2(exponent)) - 1.0) * 8388608.0; \n    float t = biased_exponent / 2.0; \n    float last_bit_of_biased_exponent = fract(t) * 2.0; \n    float remaining_bits_of_biased_exponent = floor(t); \n    float byte4 = extract_bits(fraction, 0.0, 8.0) / 255.0; \n    float byte3 = extract_bits(fraction, 8.0, 16.0) / 255.0; \n    float byte2 = (last_bit_of_biased_exponent * 128.0 + extract_bits(fraction, 16.0, 23.0)) / 255.0; \n    float byte1 = (sign * 128.0 + remaining_bits_of_biased_exponent) / 255.0; \n    return vec4(byte4, byte3, byte2, byte1); \n}\n\nvoid main(void) {\n  vec4 texData = texture2D(u_physData, gl_FragCoord.xy / 255.0);\n  float data;\n  if (u_index == 0.0) {\n    data = texData.x;\n  } else if (u_index == 1.0) {\n    data = texData.y;\n  } else if (u_index == 2.0) {\n    data = texData.z;\n  } else if (u_index == 3.0) {\n    data = texData.w;\n  }\n\n  gl_FragColor = encode_float(data);\n}\n";
export default _default;
