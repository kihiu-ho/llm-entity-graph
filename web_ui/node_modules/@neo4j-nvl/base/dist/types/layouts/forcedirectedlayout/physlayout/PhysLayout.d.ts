import type { ForceDirectedOptions, NvlState } from '../../../modules/state/types';
import type { Node, Relationship } from '../../../types/graph-element';
import type { Point } from '../../../utils/geometry';
export declare class PhysLayout {
    private physVbo;
    private physSmallVbo;
    private physProjection;
    private physSmallProjection;
    private gl;
    private useReadpixelWorkaround;
    private averageNodeSize;
    private shouldUpdate;
    private iterationCount;
    private lastSpeedValues;
    private rollingAvgGraphSpeed;
    private nodeVariation;
    private nodeCenterPoint;
    private peakIterationMultiplier;
    private stateDisposers;
    private state;
    private dpr;
    private intelWorkaround;
    private simulationStopVelocitySquared;
    private gravity;
    private force;
    private nodeIdToIndex;
    private nodeIndexToId;
    private numNodes;
    private solarMerger;
    private subGraphs;
    private nodeSortMap;
    private firstUpdate;
    private curPhysData;
    private apprxRepForceShader;
    private levelsClusterTexture;
    private levelsFinestIndexTexture;
    private initalLevelTexture;
    private levelsData;
    private collisionDetectionMultiplier;
    private physShader;
    private physData;
    private workaroundData;
    private pinData;
    private updateData;
    private updateShader;
    private workaroundShader;
    private physPositions;
    private springTexture;
    private sizeTexture;
    private offsetTexture;
    private pinTexture;
    private addedNodes;
    private updateTexture;
    enableVerlet: boolean;
    constructor(config: ForceDirectedOptions & {
        webGLContext: WebGL2RenderingContext;
        state: NvlState;
    });
    /**
     * Sets the layout options
     * @param {ForceDirectedOptions} options the object with the options
     * @param {boolean} [initial=false] whether this is the first setting of options
     */
    setOptions(options?: ForceDirectedOptions, initial?: boolean): void;
    /**
     * Sets graph data to be used
     * @param {{ nodes: Node[]; rels: Relationship[] }} data the graph object
     * @returns the top level graph of the subgraphs created by the solar merger
     */
    setData(data: {
        nodes: Node[];
        rels: Relationship[];
    }): any;
    /**
     * Updates the node's positions for the next step in the physics layout iterations if the layout needs to update
     * @param refreshPositions whether the entire layout should be reheated
     * @returns whether the layout should update in the following step
     */
    update(refreshPositions?: boolean): boolean;
    /**
     * Stops the layout
     */
    terminateUpdate(): void;
    /**
     * Returns whether the current layout needs to be updated in the next iteration step.
     * @returns {boolean} Whether the layout should update in the following step.
     */
    getShouldUpdate(): boolean;
    /**
     * Returns whether the current layout is computing.
     * Always returns false because the force-directed layout has no computing step
     * @returns {boolean} Whether the layout is computing.
     */
    getComputing(): boolean;
    /**
     * Adds the current x,y coordinates for each node to a given list of nodes.
     * @param {Node[]} nodeList The list of nodes to get positions for.
     * @returns {(Node & Point)[]} The list of nodes containing the x,y coordinates on each node object.
     */
    getNodePositions(nodeList: Node[]): (Node & Point)[];
    /**
     * Reheats the layout
     * @param {Object} fullData The entire graph object.
     */
    reheat(fullData: {
        nodes: Node[];
        rels?: Relationship[];
    }): void;
    /**
     * Updates the existing nodes of a graph with a given list of updates
     * @param {Node[]} nodeList The list of updates.
     */
    updateNodes(nodeList: Node[]): void;
    /**
     * Adds and removes nodes from the graph based on given updates
     * @param {Object} fullData The entire graph object.
     * @param {Array<Object>} fullData.nodes the nodes in the graph
     * @param {Array<Object>} fullData.rels the relationships in the graph
     * @param {Object} nodeChanges The changes in the graph.
     * @param {Array<Object>} nodeChanges.adds A list of nodes to be added.
     * @param {Array<Object>} nodeChanges.removes A list of nodes to be removed.
     */
    addRemoveData(fullData: {
        nodes: Node[];
        rels: Relationship[];
    }, nodeChanges: {
        adds: Record<string, Node>;
        removes: Record<string, Node>;
    }): any;
    /**
     * Destroys the class and all buffers and textures.
     */
    destroy(): void;
    private dumpTexture;
    private getScaleNumber;
    private getBaseLength;
    private checkForUpdates;
    private getNodePosition;
    private getMaxSpeedSquared;
    private getMedianSpeedSquared;
    private getPhysData;
    private newTexture;
    private newFramebuffer;
    private checkCompatibility;
    private printGlStats;
    private adjustToGlSize;
    private setupSize;
    private setupSprings;
    private setupPhysics;
    private setupPhysicsForNodes;
    private setupPhysicsForCoarse;
    private setupPinData;
    private setupUpdates;
    private setupReadpixelWorkaround;
    private doReadpixelWorkaround;
    private definePhysicsArrays;
}
