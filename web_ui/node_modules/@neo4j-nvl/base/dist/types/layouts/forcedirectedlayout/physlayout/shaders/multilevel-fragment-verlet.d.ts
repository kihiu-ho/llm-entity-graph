declare const _default: "precision mediump float;\n\nuniform sampler2D u_physData;\nuniform sampler2D u_connections;\nuniform sampler2D u_connectionOffsets;\nuniform sampler2D u_pinnedNodes;\nuniform sampler2D u_sizeTexture;\nuniform float u_baseLength;\nuniform float u_curIteration;\nuniform float u_iterationMultiplier;\nuniform vec2 u_gravityCenter;\nuniform float u_numNodes;\nuniform float u_gravity;\n\nuniform sampler2D u_clusterData;\nuniform sampler2D u_prevForce;\nuniform float u_collisionMultiplier;\n\n\nfloat DAMP = 0.6;\nfloat COOL = 0.99998;\nfloat TEMP = max(0.02, pow(COOL, u_curIteration));\nfloat TIMESTEP = 1.0 / 30.0;\nfloat VELOCITYDECAY = 0.6;\nfloat accLimitLow = 500000.0;\nfloat accLimitHigh = 750000.0;\nfloat accLimitPosHigh = 10000000.0;\n\nconst float denseNodeThreshold = 1000.0;\nconst float MIN_DISTANCE = 0.00000001;\nconst float MAX_DISTANCE = 1000000000.0;\nconst float MAX_ACCELERATION = 50000.0;\n\nvec4 getTextureData(sampler2D texture, float index, float base) {\n  float x = mod(index, base);\n  float y = (index - x) / base;\n  return texture2D(texture, vec2(x + 0.5, y + 0.5) / base);\n}\n\nbool isNan(float val) {\n  return (val < 0.0 || 0.0 < val || val == 0.0) ? false : true;\n}\n\nconst float BIG_NUMBER = 999999999999999999.0;\nbool isInf(float val) {\n  return val > BIG_NUMBER || val < -BIG_NUMBER;\n}\n\nvec2 getDelta(vec2 v1, vec2 v2) {\n  vec2 delta = v1 - v2;\n  float dist = length(delta);\n  if (dist < MIN_DISTANCE || isNan(dist)) {\n    return vec2(MIN_DISTANCE, MIN_DISTANCE);\n  }\n  if (dist > MAX_DISTANCE) {\n    vec2 normDelta = delta / dist;\n    return normDelta * MAX_DISTANCE;\n  }\n  return delta;\n}\n\nvec4 getOtherNodePosition(float i) {\n  return getTextureData(u_physData, i, 256.0);\n}\n\nfloat getCombinedNodeSize(float i, float nodeSize) {\n  float otherNodeSize = getTextureData(u_sizeTexture, i, 256.0).a;\n  return nodeSize + otherNodeSize;\n}\n\nvec2 getSpringForce(float curConnection, float numConnections, float springFScale, vec4 myPosition, float i) {\n  float curSpring = getTextureData(u_connections, curConnection + i, 4096.0).a;\n\n  vec4 otherPosition = getTextureData(u_physData, curSpring, 256.0);\n  float otherDataPosition = getTextureData(u_connectionOffsets, curSpring, 256.0).a;\n  float avgDegree;\n#if INTEL_WORKAROUND\n    avgDegree = max(numConnections, 4.0);\n#else\n    float otherNumConnections = getTextureData(u_connections, otherDataPosition, 4096.0).a;\n    avgDegree = max((otherNumConnections + numConnections * 3.0) / 4.0, 4.0);\n#endif\n\n  vec2 delta = getDelta(myPosition.xy, otherPosition.xy);\n  float dist = length(delta);\n\n  float F = (dist * dist * springFScale) / (u_baseLength * avgDegree);\n  if (u_collisionMultiplier > 0.0) {\n    F *= u_collisionMultiplier;\n  }\n  return (-delta / dist) * F;\n}\n\nvec2 getCollisionForce(float combinedNodeSize, float dist, float fScale, vec2 delta) {\n  float collisionForce = (combinedNodeSize - dist) / (dist);\n  if (u_collisionMultiplier > 0.0) {\n    collisionForce *= u_collisionMultiplier;\n  }\n  return (delta * collisionForce * fScale * combinedNodeSize) / (combinedNodeSize + 1.0);\n}\n\nvec2 getRepulsionForce(float dist, float fScale, vec2 delta) {\n  float F = (u_baseLength * u_baseLength * fScale) / (dist);\n  return (delta / dist) * F * 0.05;\n}\n\nvoid main(void) {\n  float textureSide = 256.0; //#TEXTURE_SIDE#;\n  float index = (gl_FragCoord.x - 0.5) + (gl_FragCoord.y - 0.5) * textureSide;\n\n  if (index >= u_numNodes) {\n    discard;\n  }\n\n  vec4 clusterData = getTextureData(u_clusterData, index, 256.0);\n\n  float clusterIndex = clusterData.x;\n  float clusterStartIndex = clusterData.y;\n  float clusterSize = clusterData.z;\n  float clusterWeight = clusterData.w;\n\n  vec4 myPosition = getTextureData(u_physData, index, 256.0);\n  vec4 previousForce = getTextureData(u_prevForce, clusterIndex, 256.0);\n\n  vec2 acceleration = previousForce.xy;\n\n  float isPinned = getTextureData(u_pinnedNodes, index, 256.0).a;\n  float nodeSize = getTextureData(u_sizeTexture, index, 256.0).a;\n\n  if (isPinned > 0.5) {\n    gl_FragColor = vec4(myPosition.xy, 0.0, 0.0);\n    return;\n  }\n\n  float curConnection = getTextureData(u_connectionOffsets, index, 256.0).a;\n  float numConnections = getTextureData(u_connections, curConnection, 4096.0).a;\n\n  float fScale = 1.0 + sqrt(u_iterationMultiplier);\n  float springFScale = fScale;\n\n  if (numConnections > denseNodeThreshold) {\n    springFScale = sqrt(fScale);\n  }\n\n  float numOfRels = 0.0;\n\n  // Springs\n  for (float i = 1.0; i <= 256.0 * 256.0; i++) {\n    if (numOfRels >= numConnections) {\n      break;\n    }\n    acceleration += getSpringForce(curConnection, numConnections, springFScale, myPosition, i);\n    numOfRels += 1.0;\n  }\n\n  // Repulsion && collision detection\n  if (u_collisionMultiplier > 0.0) {\n    float number_of_collisions = 0.0;\n    for (float i = 0.0; i < 256.0 * 256.0; i++) {\n      if (i >= u_numNodes) {\n        break;\n      }\n\n      if (i == index) {\n        continue;\n      }\n\n      vec4 otherPosition = getOtherNodePosition(i);\n      vec2 delta = getDelta(myPosition.xy, otherPosition.xy);\n      float dist = length(delta);\n      float combinedNodeSize = getCombinedNodeSize(i, nodeSize) * 2.0;\n\n      if (dist < combinedNodeSize && number_of_collisions < 40.0) {\n        number_of_collisions++;\n        acceleration += getCollisionForce(combinedNodeSize, dist, fScale, delta);\n      }\n\n      if (i >= clusterStartIndex && i < clusterStartIndex + clusterSize) {\n        acceleration += getRepulsionForce(dist, fScale, delta);\n      }\n    }\n  } else {\n    for (float i = 0.0; i < 256.0 * 256.0; i++) {\n      if (i >= clusterStartIndex + clusterSize || i >= u_numNodes) {\n        break;\n      }\n\n      if (i < clusterStartIndex || i == index) {\n        continue;\n      }\n\n      vec4 otherPosition = getOtherNodePosition(i);\n      vec2 delta = getDelta(myPosition.xy, otherPosition.xy);\n      float dist = length(delta);\n      float combinedNodeSize = getCombinedNodeSize(i, nodeSize);\n\n      if (dist < combinedNodeSize) {\n        acceleration += getCollisionForce(combinedNodeSize, dist, fScale, delta);\n      }\n\n      acceleration += getRepulsionForce(dist, fScale, delta);\n    }\n  }\n\n  // Gravity\n  vec2 delta = getDelta(u_gravityCenter, myPosition.xy);\n  float dist = length(delta);\n\n  vec2 grav = (delta / dist) * u_gravity * fScale;\n  acceleration += grav * smoothstep(0.0, 500.0, dist);\n\n  float accMagnitude = length(acceleration);\n  acceleration *= min(MAX_ACCELERATION, accMagnitude) / accMagnitude;\n\n  float iterationFrictionThreshold = 1000.0;\n\n  if (u_curIteration > iterationFrictionThreshold) {\n    float friction = 1.0 + pow((u_curIteration - iterationFrictionThreshold), 2.0) / 100.0;\n    acceleration *= 1.0 / friction;\n  }\n\n  if (u_curIteration == 0.0) {\n    gl_FragColor = vec4(myPosition.xy, myPosition.zw);\n  } else {\n    vec2 prevVelocity = myPosition.zw;\n    vec2 currentPos = myPosition.xy;\n    vec2 prevPos = currentPos - prevVelocity;\n\n    vec2 newPos = currentPos + TEMP * ( DAMP * (prevVelocity) + acceleration * TIMESTEP * TIMESTEP);\n    vec2 newVelocity = newPos - currentPos;\n    gl_FragColor = vec4(newPos, newVelocity);\n  }\n}";
export default _default;
